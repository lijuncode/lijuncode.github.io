<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/lijun.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/lijun.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/lijun.jpg">
  <link rel="mask-icon" href="/images/lijun.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lijun.xyz","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="iOS开发者，正在不断学习编程之道。">
<meta property="og:type" content="website">
<meta property="og:title" content="LiJun&#39;s Blog">
<meta property="og:url" content="http://lijun.xyz/index.html">
<meta property="og:site_name" content="LiJun&#39;s Blog">
<meta property="og:description" content="iOS开发者，正在不断学习编程之道。">
<meta property="og:locale">
<meta property="article:author" content="lijun">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://lijun.xyz/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>LiJun's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LiJun's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://lijun.xyz/2020/12/12/learn-english/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lijun">
      <meta itemprop="description" content="iOS开发者，正在不断学习编程之道。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiJun's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/12/learn-english/" class="post-title-link" itemprop="url">英语学习方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-12 23:00:45" itemprop="dateCreated datePublished" datetime="2020-12-12T23:00:45+08:00">2020-12-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-13 01:17:04" itemprop="dateModified" datetime="2020-12-13T01:17:04+08:00">2020-12-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>模仿和重复是唯一的方法</p>
<ol>
<li>花更多的时间来学习使用频率更高的英语。</li>
<li>学习正确的英语，除非必要，尽量少接触错误的英语表达，以免潜移默化。</li>
<li>不要给自己的英语词汇量设限。</li>
</ol>
<p>一、单词</p>
<p>单词是学习英语的基础，大部分英语母语者的词汇量在2万-3万5之间，需要把2万词汇量作为目标。每天背单词形成习惯。</p>
<p>背单词的标准，至少是看到单词就能想起它的中文意思。</p>
<p>每天最好背300个单词，一天后基本会忘掉70%。一开始可以先从100个开始，逐渐增加到300个。我现在用扇贝单词每天背105个（35个新词+70旧词）需要半小时，如果增加到300，就需要1个半小时。太多了点，最好还是控制在一小时，一小时的时间尽量多背。</p>
<p>关键是要坚持，即使今天没有完成背单词的任务，但只要背了单词，也是好的，重要的是坚持。</p>
<p>二、语法</p>
<p>母语者不需要专门学习语法，是因为在日常的模仿和重复中，不知觉掌握了规律。但对于外语学习者来说，没有这样的环境和大量的模仿与重复，专门学习语法是有必要的。</p>
<p>在阅读时，如果你遇到了单词都认识，但就是读不懂的句子，那么就说明你在语法方面出现了问题。 这时，请你查阅语法书，通过语法书的解释彻底搞定这种语法现象。</p>
<p>在理解了这个句子之后，把这种语法现象和你自己碰到的句子记下来，当作是你要背的一个生单词，加到你每天的背单词任务里。</p>
<p>语法书：《英语阅读参考手册》、《柯林斯英语语法大全》</p>
<p>三、阅读</p>
<p>养成阅读的习惯，对于雅思阅读成绩低于5.5分的，先从《新概念英语》第三册和第四册的文章开始。</p>
<p>辅助精读法：</p>
<p>你读每一篇文章，都应该让自己对这篇文章的理解达到母语的水平：从第一篇训练文章开始，我们要让每一篇英文文章读起来都像读汉语一样。</p>
<p>至少要把一篇文章读七遍</p>
<p>第一遍：掌握文章大意，标注出所有不认识的单词（不要写在单词边上）<br>第二、三遍：不看单词意思，能记住认出所有的单词<br>第四遍： 解决了单词问题，如果还有不懂的句子，就要对不懂的句子做句法分析<br>第五遍： 做过句子分析后，仍然有不懂的，查看语法书《英语阅读参考手册》或语法书，彻底弄懂相关语法<br>第六、七遍： 再通读，把单词和句子读通顺，做到像读汉语一样。</p>
<p>精读完成后，把单词记录到背单词软件里，把语法点也记录下来，以后复习记忆。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://lijun.xyz/2020/12/12/habit-and-goal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lijun">
      <meta itemprop="description" content="iOS开发者，正在不断学习编程之道。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiJun's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/12/habit-and-goal/" class="post-title-link" itemprop="url">忘记目标，专注于体系——《掌控习惯》读书笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-12 16:51:54 / Modified: 16:53:02" itemprop="dateCreated datePublished" datetime="2020-12-12T16:51:54+08:00">2020-12-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Reading/" itemprop="url" rel="index"><span itemprop="name">Reading</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们每个人都想要养成一个好习惯，都听过21天养成一个习惯的说法。我本人也尝试过多次去养成各种习惯，比如跑步、写日记、背单词等等，不过毫无意外地大部分都是坚持了一段时间后，就慢慢地不再坚持了，最后放弃了。最长的有坚持了几个月的，最后还是中断放弃了。</p>
<p>以前没有去深思为啥最后就放弃了，直到看到《掌控习惯》的这一章，有种恍然大悟的感觉。以前我都是以某个具体的目标去做这些事，一旦目标达成了，或者感觉目标难以达成，最后就放弃了。</p>
<p>比如我曾经在14年坚持跑步大半年的时间，当时设定了一个跑马拉松的目标，最后当年跑了3次马拉松，跑了马拉松后，就慢慢地很少再跑步了。因为我跑马拉松的目标已经实现了，就一下子没有了继续去跑步的动力了。</p>
<p>只专注于目标，不管最后能不能实现目标，都容易导致我们放弃这个习惯：</p>
<p>1、如果实现了目标，那这也只是一个短暂的改变。比如我上面的跑马拉松，我幸苦训练了半年，跑完了马拉松，这就只是改变了半年。之后又是一切照旧回到原点。而我们要养成习惯的最大的目的，应该是通过习惯每天收获一点，为未来五年、十年、二十年，乃至一生带来巨大收益，而不是为了这一个短暂的目标。</p>
<p>2、如果目标不能实现，或者需要特别长的时间，而我们又只专注于目标，我们就很会感动气馁、挫败，严重地可能会自我怀疑否定，这就很容易使我们放弃坚持这个习惯。</p>
<p>体系和目标则不同，目标侧重结果，体系注重过程。还是以跑步为例，我的目标可能是四小时跑完马拉松，而体系则是每天、每周、每月的跑量，科学地锻炼身体各个部分的素质的方法。这样我只专注于每天具体的跑步训练，只要我这个跑步训练体系正常运行，我就能享受整个过程。体系相比习惯，更加容易坚持，更加持久，收益也更加大。</p>
<p>所以，如果你想要真正获得习惯，就别再设定目标，应该专注于你的体系。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://lijun.xyz/2020/12/05/macbookpro-m1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lijun">
      <meta itemprop="description" content="iOS开发者，正在不断学习编程之道。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiJun's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/05/macbookpro-m1/" class="post-title-link" itemprop="url">iOS 程序员使用M1芯片MacBook Pro两天体验</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-05 23:12:11 / Modified: 23:14:26" itemprop="dateCreated datePublished" datetime="2020-12-05T23:12:11+08:00">2020-12-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/" itemprop="url" rel="index"><span itemprop="name">Tech</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>笔者是11号在官网下单的16G+512G的MacBook Pro，25号从上海发货，27号下午到手的。到今天已经差不多用了两天，体验下来，对于iOS开发，总结一句话，就是性能强劲，但尚有兼容问题。</p>
<p>笔者之前用的是18款的6核i7的15.6寸MacBook Pro，依然是16G+521G的组合。首先是用XcodeBanchmark这个项目测试了下，在i7的Mac上花了287秒，M1的Mac花了128秒。</p>
<p>接下来是在真机上编译公司的项目，公司的项目依赖了47个库，先clean cache后在编译，i7的Mac花了270秒，M1的Mac花了165秒。编译速度差不多是i7的1.7倍，提升还是很大的。<br><img src="/images/%E6%88%AA%E5%B1%8F2020-11-29%20%E4%B8%8B%E5%8D%883.13.07.png" alt="截屏2020-11-29 下午3.13.07"></p>
<p>另外，在编译过程中，风扇几乎没有转动，所以也没有什么噪音。只是在后面的持续测试中，如果短时间连续编译多次，温度升高后，风扇才开始转动起来。但相比i7的，只要一开始编译，风扇就开始呼呼转动，已经是非常好了。</p>
<p>那么，测试到这里，是不是意味着M1的MacBook Pro对于iOS开发者已经非常完美了呢，并不是。上面测试公司项目的时候，我是直接把旧电脑里的项目整体拷贝到新电脑里测试的。接下来，我在M1的MacBook Pro上配置完整的开发环境时，就遇到了兼容性问题。</p>
<p>第一个兼容问题，是在bundle install 和 pod install 的时候，安装使用ffi时，一直报错，导致pod instal一直失败，最后通过搜索，参照<a target="_blank" rel="noopener" href="https://github.com/CocoaPods/CocoaPods/issues/10220%E7%9D%80%E9%87%8C%E9%9D%A2%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E7%94%A8">https://github.com/CocoaPods/CocoaPods/issues/10220着里面的方法，用</a> <code>arch -x86_64 gem install ffi</code>，才最终成功。</p>
<p>第二个兼容问题，是在模拟器中编译时，一直报错”building for iOS Simulator, but linking in object file built for iOS, file ‘…/xxx.a’ for architecture arm64”，试了网上各种方式，都解决不了，依然报错，最后是通过使用Rosetta运行Xcode，才最终在模拟器上编译成功，但由此带来了巨大的性能下降，编译速度直接降到i7的水平。</p>
<p>我自己分析在模拟器中编译失败的原因是，一些第三方的静态库，对于模拟器只编译了x86的版本，没有arm64的版本，而在M1芯片的MacBook里，模拟器也变成了arm架构，需要arm64的版本，因此导致编译到最后链接阶段时报错失败。</p>
<p>因此，我们可以推测，目前有不少第三方库在M1的Mac上会有兼容问题，在GitHub上，我也的确发现了几个这样的库。比如firebase就有这个问题：<a target="_blank" rel="noopener" href="https://github.com/firebase/firebase-ios-sdk/issues/6520">https://github.com/firebase/firebase-ios-sdk/issues/6520</a></p>
<p>这个兼容问题，只是在模拟器中编译时才有，如果时在真机编译，是不会有的，因为过去和现在，真机都是arm架构的。</p>
<p>以上是我使用M1的MacBook Pro两天的体验，目前来看着两个兼容问题都不大，都可以解决。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://lijun.xyz/2020/11/21/LinkedList/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lijun">
      <meta itemprop="description" content="iOS开发者，正在不断学习编程之道。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiJun's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/21/LinkedList/" class="post-title-link" itemprop="url">Swift实现数据结构与算法1-链表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-21 15:56:51" itemprop="dateCreated datePublished" datetime="2020-11-21T15:56:51+08:00">2020-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-22 14:08:05" itemprop="dateModified" datetime="2020-11-22T14:08:05+08:00">2020-11-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>链表（Linked list）是一组数据元素（又称为节点：node）在一个线性序列中的集合，它和数组一样都是一种线性结构，但与数组不同的是，数组内元素的逻辑次序和物理存储地址是对应的，而链表则不是，相邻元素的存储地址未必相邻。为了知道每个元素的地址，上一个元素中会存储下一个元素的地址。因此相比数组访问元素是通过“寻秩访问”（call-by-rank），链表则是“循位置访问”（call-by-position），或者“循链接访问”（call-by-link）。<img src="/images/16060200177597.jpg"></p>
<p>链表又分为单向链表、双向链表、循环链表，单链表是只有一个前进方向，只能从一个节点链接到下一个节点，而双向链表既可以链接到下一个节点，也可以链接到上一个节点。循环列表则是链表首尾也是链接的。这里只实现单向链表。<br><img src="/images/IMG_0507.jpg" alt="IMG_0507"></p>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>链表的元素读取性能是O(n)，在最坏的情况下，需要遍历所有的元素，才能访问到需要的元素。<br>插入和删除性能是O(1)，每次只需要常数的时间就能插入和删除元素。</p>
<h2 id="Swift实现"><a href="#Swift实现" class="headerlink" title="Swift实现"></a>Swift实现</h2><p>根据上面的定义，我们可以知道，链表里的元素除了自身的值外，还需要指向下一个元素，所以我们可以定义<code>Node</code>类如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Node&lt;Value&gt; &#123;</span><br><span class="line">  public var value: Value</span><br><span class="line">  public var next: Node?</span><br><span class="line">  public init(value: Value, next: Node? &#x3D; nil) &#123;</span><br><span class="line">    self.value &#x3D; value</span><br><span class="line">    self.next &#x3D; next</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同时为了方便打印数据，我们为<code>Node</code>实现<code>CustomStringConvertible</code>协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">extension Node: CustomStringConvertible &#123;</span><br><span class="line">  public var description: String &#123;</span><br><span class="line">    guard let next &#x3D; next else &#123;</span><br><span class="line">      return &quot;\(value)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;\(value) -&gt; &quot; + String(describing: next) + &quot; &quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来我们实现一个<code>LinkedList</code>类，这个类有head、trail、count三个属性，为了保护数据安全，这三个属性不允许外界直接设置，同样为其实现`CustomStringConvertible``协议：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedList&lt;Value&gt; &#123;</span><br><span class="line"></span><br><span class="line">  public private(set) var head: Node&lt;Value&gt;?</span><br><span class="line">  public private(set) var tail: Node&lt;Value&gt;?</span><br><span class="line">  public private(set) var count: Int &#x3D; 0</span><br><span class="line"></span><br><span class="line">  public init(value: Value? &#x3D; nil) &#123;</span><br><span class="line">    if let value &#x3D; value &#123;</span><br><span class="line">      head &#x3D; Node(value: value)</span><br><span class="line">      tail &#x3D; head</span><br><span class="line">      count &#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public var isEmpty: Bool &#123;</span><br><span class="line">    return count &#x3D;&#x3D; 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension LinkedList: CustomStringConvertible &#123;</span><br><span class="line">  public var description: String &#123;</span><br><span class="line">    guard let head &#x3D; head else &#123;</span><br><span class="line">      return &quot;Empty list&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    return String(describing: head)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如此，一个链表就定义好了，但现在只有初始化init方法，还没有查找、插入、删除等操作的方法，接下来我们来一一添加这些方法。</p>
<h3 id="查找："><a href="#查找：" class="headerlink" title="查找："></a>查找：</h3><p>为了后续操作的方便，我们先添加一个查找方法，通过位置查找对应的节点。上面概念部分已经讲到，链表的存储位置和逻辑秩序是没有对应关系的，要查找某个位置的节点，只能通过前驱节点一步步找下一个节点。因此耗时是O(n)，在最坏的情况下需要查找n次。具体实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public func node(at index: Int) -&gt; Node&lt;Value&gt;? &#123;</span><br><span class="line">  guard index &lt; count else &#123;</span><br><span class="line">    return 0</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var currentIndex &#x3D; 0</span><br><span class="line">  var currentNode &#x3D; head</span><br><span class="line">  while currentIndex &lt; index, currentNode !&#x3D; nil &#123;</span><br><span class="line">    currentIndex +&#x3D; 1</span><br><span class="line">    currentNode &#x3D; currentNode?.next</span><br><span class="line">  &#125;</span><br><span class="line">  return currentNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="添加操作："><a href="#添加操作：" class="headerlink" title="添加操作："></a>添加操作：</h3><ol>
<li>push：添加一个元素到链表头部</li>
<li>append：添加一个元素到链表尾部</li>
<li>insert(after:)：添加一个元素到特定节点后</li>
</ol>
<p>做这三个操作的时候，需要注意要更新head、tail和count。<br>以上三个添加操作的性能都是O(1)。</p>
<p><img src="/images/IMG_0508.jpg" alt="IMG_0508"></p>
<h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><p>添加元素到头部，有两种情况:<br>一是此时链表还没有头部，还是空链表，那么就需要同时设置head和tail;<br>二是链表已经有头部了，就需要先把原来的头部作为新节点的下一个节点，然后在把这个节点设为head。</p>
<p>最后count加1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public func push(_ value: Value) &#123;</span><br><span class="line">    let newNode &#x3D; Node(value: value, next: head)</span><br><span class="line">    head &#x3D; newNode</span><br><span class="line">    if tail &#x3D;&#x3D; nil &#123;</span><br><span class="line">      tail &#x3D; head</span><br><span class="line">    &#125;</span><br><span class="line">    count +&#x3D; 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="append"><a href="#append" class="headerlink" title="append"></a>append</h4><p>添加元素到尾部，也是有两种情况：<br>一是此时链表为空，没有头部尾部，那么和push操作相同；<br>二是链表不为空，有尾部，那就需要把新节点设为旧尾部的下一个节点，并把新节点设为tail。<br>最后count加1.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public func append(_ value: Value) &#123;</span><br><span class="line">    if isEmpty &#123;</span><br><span class="line">      push(value)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let newNode &#x3D; Node(value: value)</span><br><span class="line">    tail?.next &#x3D; newNode</span><br><span class="line">    tail &#x3D; newNode</span><br><span class="line">    count +&#x3D; 1</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<h4 id="insert-after"><a href="#insert-after" class="headerlink" title="insert(after:)"></a>insert(after:)</h4><p>添加元素到某个节点后面，需要先把该节点的next设置为新节点的next，再把新节点设为该节点的next。此时链表不为空，head不需要更新，但是要考虑是否需要更新tail，如果是添加在tail后面，那就和append操作一样，可以直接调用append方法，具体实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public func insert(_ value: Value, after node: Node&lt;Value&gt;) -&gt; Node&lt;Value&gt; &#123;</span><br><span class="line">    if node &#x3D;&#x3D;&#x3D; tail &#123;</span><br><span class="line">      append(value)</span><br><span class="line">      return tail!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.next &#x3D; Node(value: value, next: node.next)</span><br><span class="line">    return node.next!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="insert-at"><a href="#insert-at" class="headerlink" title="insert(at:)"></a>insert(at:)</h4><p>此外还可以添加节点到某个位置index，利用我们上面的查找方法，先找出index-1位置的节点，再调用上面的insert方法。此时就需要注意index == 0的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@discardableResult</span><br><span class="line">  public func insert(_ value: Value, at index: Int) -&gt; Node&lt;Value&gt;? &#123;</span><br><span class="line">    guard count &gt; 0 else &#123;</span><br><span class="line">      push(value)</span><br><span class="line">      return head!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    guard index &gt; 0 else &#123;</span><br><span class="line">      insert(value, after: head!)</span><br><span class="line">      return head!.next!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if let node &#x3D; node(at: index - 1) &#123;</span><br><span class="line">      return insert(value, after: node)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nil</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="删除操作："><a href="#删除操作：" class="headerlink" title="删除操作："></a>删除操作：</h3><p>删除操作也主要是有三个：</p>
<ol>
<li>pop：删除头部节点，即head</li>
<li>removeLast：删除尾部节点：即tail</li>
<li>remove(after:)：删除某个节点的下一个节点</li>
<li>remove(at:)：删除某个位置的节点</li>
</ol>
<p>删除操作也需要考虑是否需要更新head和tail，同时需要给count做减1操作</p>
<p>以上三个删除操作中1、3的性能是O(1)，2的性能是O(n)。</p>
<h4 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h4><p>删除头部节点，删除后，需要把head.next设置为新head，实际只需要重新设置head即可。另外需要注意tail是否需要更新，当只有一个节点时，删除一个后，tail也需要设置为nil。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@discardableResult</span><br><span class="line">public func pop() -&gt; Value? &#123;</span><br><span class="line">  guard !isEmpty else &#123; return nil &#125;</span><br><span class="line">  let oldHead &#x3D; head</span><br><span class="line">  head &#x3D; oldHead?.next</span><br><span class="line">  count -&#x3D; 1</span><br><span class="line">  if tail &#x3D;&#x3D;&#x3D; oldHead &#123;</span><br><span class="line">    tail &#x3D; nil</span><br><span class="line">  &#125;</span><br><span class="line">  return oldHead?.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="removeLast"><a href="#removeLast" class="headerlink" title="removeLast"></a>removeLast</h4><p>删除最后一个节点，其实是要做两件事，一是把tail的前驱节点的next设为nil，再tail设置为前驱节点。因此这里就涉及到要找tail的前驱节点，这个查找操作就需要O(n)的时间。我们上面已经实现了一个查找方法，这里可以直接使用了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@discardableResult</span><br><span class="line">  public func removeLast() -&gt; Value? &#123;</span><br><span class="line">    guard count &gt; 1 else &#123;</span><br><span class="line">      return pop()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let removedNode &#x3D; tail</span><br><span class="line">    let pre &#x3D; node(at: count - 2)</span><br><span class="line">    pre?.next &#x3D; nil</span><br><span class="line">    tail &#x3D; pre</span><br><span class="line">    count -&#x3D; 1</span><br><span class="line">    return removedNode?.value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="remove-after"><a href="#remove-after" class="headerlink" title="remove(after:)"></a>remove(after:)</h4><p>删除一个节点的下一个节点，同样需要考虑删除的是否是尾节点，如果是，需要更新tail：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@discardableResult</span><br><span class="line">  public func remove(after node: Node&lt;Value&gt;) -&gt; Value? &#123;</span><br><span class="line">    defer &#123;</span><br><span class="line">      if node.next &#x3D;&#x3D;&#x3D; tail &#123;</span><br><span class="line">        tail &#x3D; node</span><br><span class="line">      &#125;</span><br><span class="line">      node.next &#x3D; node.next?.next</span><br><span class="line">    &#125;</span><br><span class="line">    if node.next !&#x3D; nil &#123;</span><br><span class="line">      count -&#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">    return node.next?.value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="remove-at"><a href="#remove-at" class="headerlink" title="remove(at:)"></a>remove(at:)</h4><p>删除特定位置的节点，这个可以利用查找方法，找到前一个位置的node，再调用上面的remove(after:)方法即可，这里需要注意第0个位置时，需要特殊处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@discardableResult</span><br><span class="line">  public func remove(at index: Int) -&gt; Value? &#123;</span><br><span class="line">    guard index &gt;&#x3D; 0, index &lt; count - 1 else &#123; return nil &#125;</span><br><span class="line">    if index &#x3D;&#x3D; 0 &#123;</span><br><span class="line">      return pop()</span><br><span class="line">    &#125;</span><br><span class="line">    if let node &#x3D; node(at: index - 1) &#123;</span><br><span class="line">      return remove(after: node)</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://lijun.xyz/2018/12/04/macbookpro-2018/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lijun">
      <meta itemprop="description" content="iOS开发者，正在不断学习编程之道。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiJun's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/04/macbookpro-2018/" class="post-title-link" itemprop="url">从2014款13寸MacBook Pro升级到2018款15寸MacBook Pro使用体验</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2018-12-04 21:05:24 / Modified: 21:21:04" itemprop="dateCreated datePublished" datetime="2018-12-04T21:05:24+08:00">2018-12-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/" itemprop="url" rel="index"><span itemprop="name">Tech</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>12月2日刚入手了2018款的15寸标准顶配MacBook Pro，昨天工作使用了一天，简单谈谈作为iOS开发的使用体验，主要是和我之前在用的2014款13寸MacBook Pro的对比体验。</p>
<h2 id="两款电脑的配置和跑分对比"><a href="#两款电脑的配置和跑分对比" class="headerlink" title="两款电脑的配置和跑分对比"></a>两款电脑的配置和跑分对比</h2><p><strong>13寸 MacBook Pro （Mid 2014）</strong><br><strong>处理器：</strong> 2.6GHz 双核 Intel Core i5 处理器 ，Turbo Boost 高达 3.1GHz，3MB L3 cache<br><strong>内存：</strong> 8GB 1600MHz DDR3L</p>
<p><strong>15寸 MacBook Pro （Mid 2018）</strong><br><strong>处理器：</strong>  2.6GHz 六核第八代 Intel Core i7 处理器， Turbo Boost 最高可达 4.3GHz，9MB L3 cache<br><strong>内存：</strong> 16GB 2400MHz DDR4</p>
<p>从配置上来看，2018款相比2014款提升是非常大的，从跑分结果来看也能看出。<br>2014款跑分单核2832，多核5887；2018款单核4991，多核21190。单核跑分提升76%，多核跑分提升2.6倍。</p>
<p><img src="/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%20%E4%B8%8A%E5%8D%887.46.57.png" alt="屏幕快照 2018-12-04 上午7.46.57"></p>
<h2 id="实际工作体验："><a href="#实际工作体验：" class="headerlink" title="实际工作体验："></a>实际工作体验：</h2><p><strong>效率提升</strong><br>我平时的工作就是iOS开发，从公司项目的build时间来看，2014款完成一次build耗时480秒，2018款耗时220秒，速度提升了一倍，没有跑分上的提升这么大。</p>
<p>除了build时间外，另外一点很大的提升就是代码高亮和自动补齐更快速了。在2014款上，经常会出现代码高亮和自动补齐失效的情况，特别在项目中新建了一个文件后，需要等上很久才能有代码高亮和自动补齐。而在2018款上，新建文件后也能立马有代码高亮和自动补齐，这点对工作效率的提升特别大。</p>
<p><strong>两个缺点</strong><br>一个是触控板太大了，敲键盘的时候两个手掌都会接触到触控板挺大面积，虽然苹果做了防误触，但一天下来还是出现了多次误触的情况。<br>具体表现就是，敲着敲着代码，光标突然移到其它位置去了，或者一只手放在键盘上，另一只手操作触控板时，不能移动光标，需要把放在键盘上的手抬起来。</p>
<p>另一个缺点就是感觉散热的确不是特别好，build项目的时候，风扇呼呼转，在触控条顶部区域已经特别热了。</p>
<p><strong>其它</strong><br>触控条和指纹个人感觉挺鸡肋的，特别是指纹，目前还没有遇到需要指纹的地方，开机解锁都还是要输入密码。而且为了放下触控条，取消了左上角的实体esc键，改为了触控条里的虚拟按键，很不好按。<br>第三代的蝶式键盘手感也还可以，基本很快就能适应了。<br>音响效果的确很不错。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://lijun.xyz/2018/10/02/how-to-read-book/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lijun">
      <meta itemprop="description" content="iOS开发者，正在不断学习编程之道。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiJun's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/02/how-to-read-book/" class="post-title-link" itemprop="url">《如何有效阅读一本书》读书笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2018-10-02 11:56:01 / Modified: 11:58:06" itemprop="dateCreated datePublished" datetime="2018-10-02T11:56:01+08:00">2018-10-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Reading/" itemprop="url" rel="index"><span itemprop="name">Reading</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>#一、读书笔记的原则和方法</p>
<p><strong>1、做笔记的原则：信息一元化原则</strong><br>就是把关于读书的所有信息都放在一个地方，你的读书愿望单、读书笔记、阅读记录等等都在一个地方，这样方便记录、管理，简单易用更容易坚持。</p>
<p><strong>2、如何做笔记：坚持最重要+笔记五要素固定模板</strong><br>做读书笔记，首要的是坚持，在完成首要目标的前提下再去想如何做好笔记。而越简单的事情，越容易坚持，因此初期为了坚持，可以记最简单的笔记，比如：<br>「2017年8月26日，我读了《如何有效阅读一本书》，这本书提供了如何做读书笔记的方法。」</p>
<p>进阶一点，可以使用五要素固定模板：<br>1)、写笔记的日期<br>2)、书名<br>3)、作者<br>4)、对自己重要的内容（摘抄）<br>5)、自己的感想</p>
<p>高阶一点的，可以再插入相关信息，比如读到某个人物，可以插入这个人的图片，比如一场战争，可以插入相关地图。</p>
<p>有了固定的模板，进而形成习惯，这样每次记读书笔记就不用去思考应该记录什么内容了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://lijun.xyz/2018/05/30/kindle-oasis-review/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lijun">
      <meta itemprop="description" content="iOS开发者，正在不断学习编程之道。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiJun's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/30/kindle-oasis-review/" class="post-title-link" itemprop="url">kindle-oasis-review</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2018-05-30 23:05:29 / Modified: 23:10:41" itemprop="dateCreated datePublished" datetime="2018-05-30T23:05:29+08:00">2018-05-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Thinking/" itemprop="url" rel="index"><span itemprop="name">Thinking</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>如果你觉得Kindle不好用，那一定是你没有买Kindle Oasis</p>
</blockquote>
<p>从最早的Kindle Touch，到第一代、第二代Kindle PaperWhite，我已经使用过至少三代Kindle，目前使用的Kindle Oasis是我使用的第四代Kindle。在入手Oasis之前，我的旧Kindle PaperWhite已经吃灰很久了，而自从入手Oasis之后，我又爱上了用Kindle阅读，短短入手一周的时间，我已经看完3本书了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://lijun.xyz/2018/05/28/becoming-steve-jobs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lijun">
      <meta itemprop="description" content="iOS开发者，正在不断学习编程之道。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiJun's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/28/becoming-steve-jobs/" class="post-title-link" itemprop="url">不是谁都能成为乔布斯</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-05-28 21:53:34" itemprop="dateCreated datePublished" datetime="2018-05-28T21:53:34+08:00">2018-05-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2018-05-30 23:02:28" itemprop="dateModified" datetime="2018-05-30T23:02:28+08:00">2018-05-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Reading/" itemprop="url" rel="index"><span itemprop="name">Reading</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/s28948876-2.jpg" alt="s28948876-2"></p>
<p>之前看过《乔布斯传》，印象最深刻的是乔布斯的粗鲁和暴脾气，以及他的“现实扭曲力场”，很难相信有那么多极富才华的人会在这样一个人手下干活。而看完《成为乔布斯》，才理解了乔布斯为什么会成为乔布斯，在被苹果放逐多年之后，乔布斯为何又能上演王者归来，再次带领苹果改变世界。</p>
<p>乔布斯首先是个天才，因此得以年少成名，21岁就与沃兹创立了苹果公司，制造了世界最早商业化的个人电脑，开启了个人电脑时代。但是在公司上升阶段，乔布斯年少轻狂，自我主义等等弱点开始暴露出来，使他和公司其他管理层的关系逐渐恶化，加上乔布斯后来主导的Apple III、Lisa、Macintosh等电脑机型的销量不理想，最终使苹果的董事们抛弃了乔布斯。</p>
<p>之后乔布斯离开苹果，创立了NeXT公司，主打高校市场的工作站。尽管NeXT起步阶段获得众多高校和投资人的亲睐和投资，但乔布斯自大狂傲的性格最终还是把事情搞砸了。原本计划18个月推出的产品，一直拖到三年后才推出，而且价格远远高于市场预期，而且直到一年后才卖出去一台，此时距离乔布斯创立NeXT公司已经过去4年了。</p>
<p>乔布斯精心打造的NeXT未能如他所愿，而无心插柳收购的皮克斯动画制作室却最终获得意外成功，从1986年收购皮克斯，到后来皮克斯与迪士尼合作的3D动画电影《玩具总动员》上影，在电脑领域几乎已经被人遗忘的乔布斯才重新找回自尊，而更重要的是，皮克斯的成功经验让乔布斯学习到了重要的管理技巧：</p>
<p>“看着团队成员因为合作而变成更好的自己，我想这对史蒂夫触动很大，”拉塞特（皮克斯的首席创意官）说道，“我认为这是他重回苹果后最关键的变化之一。他能以更开放、更包容的态度来看待别人的才华，从别人的才华中得到鼓舞，同时激励别人完成他自己无法完成的伟大事业。”</p>
<p>皮克斯的动画都有一个基本套路，主人公一开始自大高傲，看不起普通人，因而遭遇挫折陷入困境，之后在某些善良人的帮助下，主人公逐渐学会了善良、勇敢、智慧等品质，克服了自身的性格弱点，最终得到救赎，完成目标。</p>
<p>虽然乔布斯的性格并没有真正改变，但他已经懂得如何有效利用自己的性格优势来达到自己的目的，并克服自己的性格缺点，不让它影响项目的发展。</p>
<p>后来，出现了不少乔布斯的模仿者。对此，比尔盖茨有一句一种见血的评语：“很多想模仿史蒂夫的人只学会了他混蛋的那一面，却学不会他作为天才的那一面。”</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://lijun.xyz/2018/01/29/Realm-basic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lijun">
      <meta itemprop="description" content="iOS开发者，正在不断学习编程之道。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiJun's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/01/29/Realm-basic/" class="post-title-link" itemprop="url">Realm数据库介绍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2018-01-29 21:53:34 / Modified: 22:04:23" itemprop="dateCreated datePublished" datetime="2018-01-29T21:53:34+08:00">2018-01-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>我在瓣读中使用了Realm做数据的持久化存储，所以把自己的一些实践体验分享一下。</p>
<p>Realm 的身世，大家可以在官网上查看，当初我是看了一遍 Realm 官网上的介绍，就很快决定了选用它，它第一眼吸引的特点有以下几点：</p>
<p>1、原生就支持 Swift，有 RealmSwift<br>2、多平台、可视化支持，同时支持iOS和Androi**d，还有一个Realm Brower应用，可以查看数据库中的内容。<br>3、使用简单方便，它不是基于Sqlite的封装，而是完全自己开发了一个数据库，完全没有那些sqlite语句，基本上看一眼示例代码就知道怎么用了。</p>
<!---- more ---->

<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>下面我们就来看一下 Realm 的一些基本操作</p>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认配置</span></span><br><span class="line"><span class="keyword">let</span> realm = <span class="keyword">try</span>! <span class="type">Realm</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义配置</span></span><br><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(fileURLWithPath: <span class="type">RLMRealmPathForFile</span>(<span class="string">&quot;evernoteData.realm&quot;</span>), isDirectory: <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">var</span> config = <span class="type">Realm</span>.<span class="type">Configuration</span>(fileURL: url)</span><br><span class="line">config.schemaVersion = realm.configuration.schemaVersion</span><br><span class="line"><span class="keyword">let</span> evernoteRealm = <span class="keyword">try</span>! <span class="type">Realm</span>(configuration: config)</span><br></pre></td></tr></table></figure>

<h3 id="add-update-delete-query"><a href="#add-update-delete-query" class="headerlink" title="add update delete query"></a>add update delete query</h3><p>需要存储到 Realm 数据库中的 Model 都必须继承自 RealmSwift 自定义的一个类： Object， 自持 Swift 的 nullability 特性，支持一对一和一对多的关系。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> RealmSwift</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dog model</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>: <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">dynamic</span> <span class="keyword">var</span> name = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">dynamic</span> <span class="keyword">var</span> owner: <span class="type">Person?</span> <span class="comment">// Properties can be optional</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person model</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">dynamic</span> <span class="keyword">var</span> name = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">dynamic</span> <span class="keyword">var</span> birthdate = <span class="type">Date</span>(timeIntervalSince1970: <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> dogs = <span class="type">List</span>&lt;<span class="type">Dog</span>&gt;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还可以给 Model 设置主键primaryKey，默认值defaultPropertyValues，忽略的属性ignoredProperties，必要属性requiredProperties，索引indexedProperties。</p>
<p>比较有用的是主键和索引，最好是给每个 Model 都设置主键，这样便于查询和更新，一开始的时候瓣读上的图书评分model没有设置主键，结果所有的书都用了同一个评分，导致评分都显示一样了。</p>
<p>要将一个 Model 添加进数据库中也很简单：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = <span class="type">Dog</span>()</span><br><span class="line"><span class="keyword">let</span> realm = <span class="keyword">try</span>! <span class="type">Realm</span>()</span><br><span class="line"><span class="keyword">try</span>! realm.write() &#123;</span><br><span class="line">    realm.add(dog)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>更新 删除 Model：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = <span class="type">Dog</span>()</span><br><span class="line"><span class="keyword">let</span> realm = <span class="keyword">try</span>! <span class="type">Realm</span>()</span><br><span class="line"><span class="keyword">try</span>! realm.write() &#123;</span><br><span class="line">    realm.add(dog, update: <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>! realm.write() &#123;</span><br><span class="line">    dog.name = <span class="string">&quot;ww&quot;</span></span><br><span class="line">    dog.setValue(<span class="string">&quot;hh&quot;</span>, forKeyPath: <span class="string">&quot;name&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="keyword">try</span>! realm.write() &#123;</span><br><span class="line">    realm.delete(dog)</span><br><span class="line">    realm.deleteAll()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查询：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> dogs = realm.objects(<span class="type">Dog</span>.<span class="keyword">self</span>) <span class="comment">// retrieves all Dogs from the default Realm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Query using a predicate string</span></span><br><span class="line"><span class="keyword">var</span> tanDogs = realm.objects(<span class="type">Dog</span>.<span class="keyword">self</span>).<span class="built_in">filter</span>(<span class="string">&quot;color = &#x27;tan&#x27; AND name BEGINSWITH &#x27;B&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Query using an NSPredicate</span></span><br><span class="line"><span class="keyword">let</span> predicate = <span class="type">NSPredicate</span>(format: <span class="string">&quot;color = %@ AND name BEGINSWITH %@&quot;</span>, <span class="string">&quot;tan&quot;</span>, <span class="string">&quot;B&quot;</span>)</span><br><span class="line">tanDogs = realm.objects(<span class="type">Dog</span>.<span class="keyword">self</span>).<span class="built_in">filter</span>(predicate)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sorting</span></span><br><span class="line"><span class="keyword">let</span> sortedDogs = realm.objects(<span class="type">Dog</span>.<span class="keyword">self</span>).<span class="built_in">filter</span>(<span class="string">&quot;color = &#x27;tan&#x27; AND name BEGINSWITH &#x27;B&#x27;&quot;</span>).sorted(byKeyPath: <span class="string">&quot;name&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>Realm 中的所有查询都是懒加载，当你执行上面这些代码的时候，真正的数据并不会加载到内存中，只有当 Model 的属性被真正访问的时候，它才回被加载。而且查询出来的结果是实时更新的。当数据发生变化时不需要再重新查询一遍。</p>
<p>通知：</p>
<p>查询出来的结果可以添加通知，监听数据库的变化，来改变UI：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UITableViewController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> notificationToken: <span class="type">NotificationToken?</span> = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="keyword">let</span> realm = <span class="keyword">try</span>! <span class="type">Realm</span>()</span><br><span class="line">        <span class="keyword">let</span> results = realm.objects(<span class="type">Person</span>.<span class="keyword">self</span>).<span class="built_in">filter</span>(<span class="string">&quot;age &gt; 5&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Observe Results Notifications</span></span><br><span class="line">        notificationToken = results.observe &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (changes: <span class="type">RealmCollectionChange</span>) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> tableView = <span class="keyword">self</span>?.tableView <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">            <span class="keyword">switch</span> changes &#123;</span><br><span class="line">            <span class="keyword">case</span> .initial:</span><br><span class="line">                <span class="comment">// Results are now populated and can be accessed without blocking the UI</span></span><br><span class="line">                tableView.reloadData()</span><br><span class="line">            <span class="keyword">case</span> .update(<span class="keyword">_</span>, <span class="keyword">let</span> deletions, <span class="keyword">let</span> insertions, <span class="keyword">let</span> modifications):</span><br><span class="line">                <span class="comment">// Query results have changed, so apply them to the UITableView</span></span><br><span class="line">                tableView.beginUpdates()</span><br><span class="line">                tableView.insertRows(at: insertions.<span class="built_in">map</span>(&#123; <span class="type">IndexPath</span>(row: $<span class="number">0</span>, section: <span class="number">0</span>) &#125;),</span><br><span class="line">                                     with: .automatic)</span><br><span class="line">                tableView.deleteRows(at: deletions.<span class="built_in">map</span>(&#123; <span class="type">IndexPath</span>(row: $<span class="number">0</span>, section: <span class="number">0</span>)&#125;),</span><br><span class="line">                                     with: .automatic)</span><br><span class="line">                tableView.reloadRows(at: modifications.<span class="built_in">map</span>(&#123; <span class="type">IndexPath</span>(row: $<span class="number">0</span>, section: <span class="number">0</span>) &#125;),</span><br><span class="line">                                     with: .automatic)</span><br><span class="line">                tableView.endUpdates()</span><br><span class="line">            <span class="keyword">case</span> .error(<span class="keyword">let</span> error):</span><br><span class="line">                <span class="comment">// An error occurred while opening the Realm file on the background worker thread</span></span><br><span class="line">                <span class="built_in">fatalError</span>(<span class="string">&quot;\(error)&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        notificationToken?.invalidate()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="数据库的迁移"><a href="#数据库的迁移" class="headerlink" title="数据库的迁移"></a>数据库的迁移</h2><p>因为瓣读是不断在增加新的功能，所以数据也是不断增加的，这就需要经常迁移数据库，而Realm要做迁移也非常简单，新增删除表和字段，都不需要做额外的操作，只有修改了字段的时候才需要做手动的迁移，这是瓣读数据库迁移的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> config = <span class="type">Realm</span>.<span class="type">Configuration</span>(</span><br><span class="line">      schemaVersion: <span class="number">2</span>,</span><br><span class="line">      migrationBlock: &#123; migration, oldSchemaVersion <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> (oldSchemaVersion &lt; <span class="number">1</span>) &#123;</span><br><span class="line">          migration.enumerateObjects(ofType: <span class="type">DBCollection</span>.className()) &#123; oldObject, newObject <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> newObject = newObject, <span class="keyword">let</span> oldObject = oldObject, <span class="keyword">let</span> oldId = oldObject[<span class="string">&quot;id&quot;</span>] <span class="keyword">as</span>? <span class="type">Int</span>  &#123;</span><br><span class="line">              newObject[<span class="string">&quot;id&quot;</span>] = <span class="type">String</span>(oldId)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="type">Realm</span>.<span class="type">Configuration</span>.defaultConfiguration = config</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="多线程操作"><a href="#多线程操作" class="headerlink" title="多线程操作"></a>多线程操作</h2><p>Realm 是一个MVCC数据库，MVCC是Multiversion concurrency control，多版本并发控制。采用的方法是，每一个连接的线程都会数据在一个特定时刻的快照，采用的是和Git一样的源文件管理算法，每一个线程都有一个特定的数据库版本，就像Git的分支。</p>
<p>因此，Realm 是不允许多个线程访问同一个数据库实例的，必须要每个线程都单独创建一个数据库实例，但线程runloop循环开始的时候，线程中的数据库实例能够自动刷新获取最新的数据库数据，也可以通过执行<code>Realm.refresh()</code> 或者 <code>Realm.commitWrite()</code> 方法来手动刷新。</p>
<p>对于需要跨线程访问的 Model， 需要用 ThreadSafeReference 来包一层：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="type">Person</span>(name: <span class="string">&quot;Jane&quot;</span>)</span><br><span class="line"><span class="keyword">try</span>! realm.write &#123;</span><br><span class="line">    realm.add(person)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> personRef = <span class="type">ThreadSafeReference</span>(to: person)</span><br><span class="line"><span class="type">DispatchQueue</span>(label: <span class="string">&quot;background&quot;</span>).async &#123;</span><br><span class="line">    autoreleasepool &#123;</span><br><span class="line">        <span class="keyword">let</span> realm = <span class="keyword">try</span>! <span class="type">Realm</span>()</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> person = realm.resolve(personRef) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="comment">// person was deleted</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>! realm.write &#123;</span><br><span class="line">            person.name = <span class="string">&quot;Jane Doe&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果想要深入了解 Realm 的多线程处理机制，可以查看这篇官方文章：<a target="_blank" rel="noopener" href="https://academy.realm.io/cn/posts/threading-deep-dive/">数据库的设计：深入理解Realm的多线程处理机制</a></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>官方列了很多缺点：一些类名、属性名的长度，属性值的大小等等，影响比较大的缺点应该就是 Model 有很多限制：</p>
<p>只能继承自 Object<br>不能重写 Setter 和 getter 方法</p>
<p>类的继承，也基本不能使用多态特性，子、父类不能互相转换，不能对多个类同时进行查询，也没有多类容器。<br>而且最蛋疼的一点是，属性不支持基本的数组和字典，有些属性其实就是一个字符串数组，但因为不支持数组，只能为一个字符串新建一个Model，里面只有一个字符串属性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://lijun.xyz/2017/08/08/bandu-read/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lijun">
      <meta itemprop="description" content="iOS开发者，正在不断学习编程之道。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiJun's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/08/bandu-read/" class="post-title-link" itemprop="url">为了更高效地在豆瓣写读书笔记，我开发了瓣读APP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2017-08-08 20:20:45 / Modified: 23:46:48" itemprop="dateCreated datePublished" datetime="2017-08-08T20:20:45+08:00">2017-08-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Project/" itemprop="url" rel="index"><span itemprop="name">Project</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>该文发布在少数派：<a target="_blank" rel="noopener" href="https://sspai.com/post/40308">为了更高效地在豆瓣写读书笔记，我开发了瓣读APP</a></p>
<blockquote>
<p>瓣读APP是一款豆瓣读书笔记客户端，能帮你快速搜索、标记图书，更高效地写读书笔记，支持在笔记中插入原文、图片、设置笔记为仅自己可见，支持文字识别插入笔记、将笔记转成长图分享。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://itunes.apple.com/app/%E7%93%A3%E8%AF%BB/id1255569882?mt=8">App Store下载</a></p>
<!---- more ---->

<h2 id="瓣读的起源"><a href="#瓣读的起源" class="headerlink" title="瓣读的起源"></a>瓣读的起源</h2><p>瓣读APP可以说是我独立开发的第一款完整的APP，最早在2015年就完成了一个初级版本，并上架到App Store。但当时只是作为一个练手项目，APP各方面都不成熟，上架大概半年之后就下架了，直到最近才重新开发了一个新版本，就是现在的瓣读。</p>
<p>开发瓣读的初衷很简单，就是为了更方便地写读书笔记。我个人是豆瓣的深度用户，平时看书也都会在豆瓣上标记，也想在豆瓣上写读书笔记，但多次尝试发现，在豆瓣上写读书笔记非常麻烦，而且还缺失功能：</p>
<ol>
<li>写读书笔记的入口非常深。在豆瓣APP里写读书笔记，至少要有5次点击，期间还有滑动操作。写读书笔记一个很重要地体验，应该是不打断阅读节奏，心有所感时，立即就能记笔记。</li>
<li>在豆瓣APP里写笔记不能插入原文。我相信大部分人写读书笔记很大一部分是摘抄原文，而在豆瓣APP里没有了插入原文这一功能。虽然pc断有，但pc端相比app，写笔记更麻烦。</li>
</ol>
<p>基于以上两点我个人在实际中遇到的痛点，我再次决定开发一个豆瓣读书笔记应用，于是有了瓣读的诞生。</p>
<h2 id="随处可见的写笔记入口"><a href="#随处可见的写笔记入口" class="headerlink" title="随处可见的写笔记入口"></a>随处可见的写笔记入口</h2><p>鉴于最大的一个痛点是写笔记的入口太深，我在瓣读APP里几乎所有可能会有写笔记需求的地方都添加了写笔记的入口，包括笔记列表页、图书列表页、图书详情页，再加上3D Touch快捷操作，总共有四个入口，让用户在任何地方都能一键写笔记。</p>
<p><img src="/images/dfbce71d5c67b0da536927752c54be7c-1.png" alt="dfbce71d5c67b0da536927752c54be7"></p>
<h2 id="文字识别插入原文"><a href="#文字识别插入原文" class="headerlink" title="文字识别插入原文"></a>文字识别插入原文</h2><p>要解决第二个痛点，在笔记编辑页面增加插入原文的功能就可以，这点很简单，但我还想把它做得更高效。在豆瓣上查看用户写的笔记会发现，很多用户都是拍一张照片就是一篇笔记了，比打字抄原文方便多了。既然如此，那我干脆就直接集成文字识别的功能，用户拍照就能自动识别成文字，并作为原文插入。为了跟方便地拍照记笔记，文字识别也有快捷入口，在3D Touch和发现tab写都可以一键拍照识别文字。</p>
<p><img src="/images/4e9bdd87ab5b2a33ea090c367da91079.png" alt="4e9bdd87ab5b2a33ea090c367da91079"></p>
<h2 id="笔记仅自己可见"><a href="#笔记仅自己可见" class="headerlink" title="笔记仅自己可见"></a>笔记仅自己可见</h2><p>笔记仅自己可见，目前是瓣读的一项独家功能，包括豆瓣官方，以及其它一些豆瓣读书笔记客户端都没有这项功能。</p>
<p>无论是在豆瓣app，还是在豆瓣网站上，写的笔记都是公开的，所有人都可以看到，但对于笔记来说，有一些是私密的，并不想给其它人看到。豆瓣的API中，已经有笔记仅自己可见的相关接口了，但官方产品并没有提供这项功能。</p>
<p>在瓣读APP中，写笔记时选中右上角的“仅自己可见”就可以。仅自己可见的笔记依然会同步到豆瓣，但不会公开，只有自己能看到。</p>
<p><img src="/images/onlyshowme.png" alt="onlyshowme"></p>
<h2 id="关于收费"><a href="#关于收费" class="headerlink" title="关于收费"></a>关于收费</h2><p>自己付出劳动开发的产品，自然希望能获得一定的收入。苹果App Store的付费方式有应用付费和应用内购。现在比较流行的是应用免费+内购解锁功能的方式。</p>
<p>内购又分为4种，分别是：</p>
<ul>
<li>消耗型：购买后只能使用一次，下次还得再次购买，典型的就是内购充值。</li>
<li>非消耗型：只需要购买一次，永久有效，典型的就是内购解锁高级功能。</li>
<li>自动续期订阅：有时效性，并会自动续订，典型的如订阅会员、期刊。</li>
<li>非续费订阅： 有时效性，但不会自动续订，这类比较少。</li>
</ul>
<p>瓣读最适合的应该是第二种非消耗型，一次购买永久解锁所有功能。但因为瓣读的文字识别用的是百度的接口，是按次数收费的，使用的次数越多，费用就越多，因此如果是一次购买，无限使用的话，一旦人数过多，就有可能会入不敷出。因此，参照萝卜书摘等应用的做法，目前仅针对文字识别功能需要购买文字识别次数，其它功能都是免费的。</p>
<h2 id="后续开发计划"><a href="#后续开发计划" class="headerlink" title="后续开发计划"></a>后续开发计划</h2><p>目前还只是完成了基础功能的开发，后续计划将会增加笔记同步到印象笔记、笔记导出、读书计划、读书统计等功能。</p>
<p><a target="_blank" rel="noopener" href="https://itunes.apple.com/app/%E7%93%A3%E8%AF%BB/id1255569882?mt=8">App Store下载</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">lijun</p>
  <div class="site-description" itemprop="description">iOS开发者，正在不断学习编程之道。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">36</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/lijuncode" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lijuncode" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/likumb" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;likumb" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lijun</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
